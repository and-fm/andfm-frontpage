---
import { Text, leaf } from "slate";
import ImageRenderer from "./BodyImageRenderer.js";
import type { Author, Media, Post } from "../../types/payload-types";

type DomTypes = 
    "h1" | "h2" | "h3" | "h4" | "h5" | "h6" |
    "p" |
    null |
    "upload" | 
    "relationship" | 
    "ul" | "ol" | "li" |
    "indent" | 
    "link"

// extends Element
type Block = {
    children: ReadonlyArray<BlockElement>,
    type?: DomTypes,
    // if there is a value, it is one of these
    value?: Media | Post
};

type BlockElement = {
    children?: ReadonlyArray<Block>,
    text?: string,
    bold?: boolean,
    italic?: boolean,
    underline?: boolean,
    strikethrough?: boolean,
    code?: boolean,
    type?: string,
}

type Link = {
    children: ReadonlyArray<BlockElement>,
    url: string,
    newTab?: boolean,
    linkType?: string,
    type: "link",
}

const { content } = Astro.props;

/**
 * Serialise a link element
 * @param node The node to serialise
 * @param className The class to apply to the link
 */
const serializeLink = async (node: Link, className: string): Promise<string> => {
    const { children, url, newTab } = node;
    const parsed = children?.map(createSpan).join("") ?? ""
    return `<a href='${url}' class="${className}" target='${newTab ? "_blank" : "_self"}'>${parsed}</a>`
}

/**
 * Serialise a relationship element
 * @param node The node to serialise
 */
const serializeRelationship = async (node: Block): Promise<string> => {
    const { title, slug, author } = node.value as Post;
    const {name} = author as Author;
    return `<div class="p-2 rounded-xl"><a href='/blog/${slug}' class='text-orange-400 hover:text-orange-400 hover:underline'>${name}: ${title}</a></div>`
}

/**
 * Create a span element from a leaf
 * @param element the leaf to create a span from
 */
const createSpan = async (element: BlockElement): Promise<string> => {
    
    // proceed
    const { text, bold, italic, underline, strikethrough, code, type } = element;
    
    if (text?.length === 0) return "";
    
    // Handle leaf types like bold, italic, etc.
    const leafTypes = {
        bold: "font-bold",
        italic: "italic",
        underline: "underline",
        strikethrough: "line-through",
        code: "bg-zinc-800 p-2 rounded-lg text-white font-mono",
        link: "text-blue-400 hover:text-blue-400 hover:underline",
    };
    
    const calculatedClass = Object.entries(leafTypes)
        .filter(([key, _]) => (key as keyof typeof leafTypes) in element)
        .map(([_, value]) => value)
        .join(" ");
    
    switch (element.type) {
        case "link": return `${serializeLink(element as Link, leafTypes.link)}`
    }
    
    return `<span class='${calculatedClass}'>${text}</span>`;
}

/**
 * Serialise a block that contains text as children
 * @param tag the HTML tag to wrap the children in
 * @param classes the classes to apply to the tag
 */
const serializeText = (tag: string, classes: string) => async (children: Readonly<BlockElement[]>): Promise<string> => {
    const parsed = (await Promise.all(children?.map(createSpan))).join("") ?? ""
    return `<${tag} class='${classes}'>${parsed}</${tag}>`
}

/**
 * Serialise a block that contains blocks as children
 * @param tag the HTML tag to wrap the children in
 * @param classes the classes to apply to the tag
 */
const serializeNested = (tag: string, classes: string) => async (children: Block[]): Promise<string> => {
    const parsed = (await Promise.all(children?.map(serializeBlock))).join("") ?? ""
    return `<${tag} class='${classes}'>${parsed}</${tag}>`
}

const serializeBlock = async (block: Block): Promise<string> => {
    const children = block.children;

    switch (block.type) {
        case "h1": return await serializeText("h1", "text-4xl font-bold text-white")(children);
        case "h2": return await serializeText("h2", "text-3xl font-bold text-white")(children);
        case "h3": return await serializeText("h3", "text-2xl font-bold text-white")(children);
        case "h4": return await serializeText("h4", "text-xl font-bold text-white")(children);
        case "h5": return await serializeText("h5", "text-lg font-bold text-white")(children);
        case "h6": return await serializeText("h6", "text-base font-bold text-white")(children);
        case "upload": return await ImageRenderer({media: block.value!, alt: (block.value as Media).alt!, mediaType: "thumbnail"}) || ""
        case "relationship": return serializeRelationship(block);
        case "ul": return await serializeNested("ul", "ml-4 list-disc text-white")(children as Block[]);
        case "ol": return await serializeNested("ol", "ml-4 list-decimal text-white")(children as Block[]);
        case "li": return await serializeText("li", "text-white")(children);
        case "indent": return await serializeNested("div", "ml-4")(children as Block[]);
        default: return await serializeText("p", "text-zinc-200")(children);
    }
}

/**
 * Elements that will be directly appended onto the rendered div
 */
const elements = await Promise.all(content.map(serializeBlock));
---

<div
    class={Astro.props.class + " flex gap-4 flex-col"}
    set:html={elements}
/>
